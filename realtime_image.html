<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ç”»åƒå‡¦ç†ãƒ‡ãƒ¢</title>
    <link rel="stylesheet" href="styles.css"> 
    
    <style>
        /* ======================================= */
        /* styles.css ã§å®šç¾©ã•ã‚Œã‚‹å…±é€šã‚¹ã‚¿ã‚¤ãƒ«ã¯çœç•¥ */
        /* ======================================= */
        
        /* ãƒšãƒ¼ã‚¸å›ºæœ‰ã®ã‚¹ã‚¿ã‚¤ãƒ«ï¼ˆstyles.css ã®å®šç¾©ã‚’å‰æã¨ã™ã‚‹ï¼‰ */
        .video-container { 
            position: relative; 
            display: inline-block; 
            margin-top: 15px;
            border: 1px solid #ccc;
            border-radius: 6px;
            overflow: hidden;
            background-color: #000;
            width: 100%; 
            max-width: 640px;
        }
        #webcamStream { 
            width: 100%; 
            height: auto;
            /* ã‚«ãƒ¡ãƒ©æ˜ åƒã‚’é¡åƒã«ã™ã‚‹ */
            transform: scaleX(-1); 
            display: block; 
        }
        #processingCanvas { 
            display: none; 
        }
        .bounding-box {
            position: absolute;
            border: 3px solid #FF0000; 
            box-sizing: border-box;
            z-index: 10; 
        }
        #statusMessage {
            margin-top: 15px;
            font-weight: bold;
            color: #333; /* åœæ­¢ä¸­ã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè‰² */
        }
    </style>
</head>
<body>
    
    <header class="header">
        <h1 class="logo">AI Powered Services</h1>
        <button class="menu-toggle" aria-expanded="false">â˜°</button>
        <nav class="main-nav">
            <ul>
                <li><a href="index.html">ãƒ›ãƒ¼ãƒ </a></li>
                <li><a href="realtime_image.html" class="active">ğŸ“· ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ç”»åƒå‡¦ç†</a></li> 
                <li><a href="realtime_translate.html">ğŸ—£ï¸ ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ç¿»è¨³</a></li>
            </ul>
        </nav>
    </header>

    <div class="main-widget-container">
        <h2>ğŸ“· ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ç‰©ä½“æ¤œçŸ¥ãƒ‡ãƒ¢</h2>
        
        <p>ã€Œã‚«ãƒ¡ãƒ©é–‹å§‹ã€ã‚’æŠ¼ã™ã¨ã€ä¸€å®šé–“éš”ã§ã‚µãƒ¼ãƒãƒ¼ã«ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’é€ã‚Šã€ç‰©ä½“æ¤œå‡ºã‚’è¡Œã„ã¾ã™ã€‚</p>

        <div class="video-container" id="videoContainer">
            <video id="webcamStream" playsinline muted></video> 
            <canvas id="processingCanvas"></canvas>
        </div>

        <div>
            <button id="startStopButton" class="primary">ã‚«ãƒ¡ãƒ©é–‹å§‹</button>
            <p id="statusMessage">ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹: åœæ­¢ä¸­</p>
        </div>
        
    </div>

    <script>
        const video = document.getElementById('webcamStream');
        const canvas = document.getElementById('processingCanvas');
        const context = canvas.getContext('2d', { willReadFrequently: true });
        const container = document.getElementById('videoContainer');
        const statusMessage = document.getElementById('statusMessage');
        const startStopButton = document.getElementById('startStopButton');
        
        let intervalId = null;
        const CAPTURE_INTERVAL = 300; // 300ãƒŸãƒªç§’ã”ã¨ã«ã‚­ãƒ£ãƒ—ãƒãƒ£ï¼ˆç´„3 FPSï¼‰
        let isProcessing = false; // å‡¦ç†ä¸­ã®ãƒ•ãƒ©ã‚°
        let cameraStream = null; // ã‚«ãƒ¡ãƒ©ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’ã‚°ãƒ­ãƒ¼ãƒãƒ«ã«ä¿æŒã™ã‚‹å¤‰æ•°
        const MAX_RETRIES = 3; // å†ç”Ÿãƒªãƒˆãƒ©ã‚¤å›æ•°

        /**
         * ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ¤œå‡ºã®é–‹å§‹/åœæ­¢ã‚’åˆ‡ã‚Šæ›¿ãˆã‚‹
         */
        function startStopDetection() {
            if (intervalId) {
                // åœæ­¢å‡¦ç†
                stopDetection();
            } else {
                // é–‹å§‹å‡¦ç†
                startCamera();
            }
        }

        /**
         * æ¤œå‡ºå‡¦ç†ã‚’å®Œå…¨ã«åœæ­¢ã—ã€UIã‚’ãƒªã‚»ãƒƒãƒˆã™ã‚‹
         */
        function stopDetection() {
            clearInterval(intervalId);
            intervalId = null;
            isProcessing = false;
            stopCameraTracks();
            startStopButton.textContent = 'ã‚«ãƒ¡ãƒ©é–‹å§‹';
            statusMessage.textContent = 'ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹: åœæ­¢ä¸­';
            statusMessage.style.color = '#333'; // åœæ­¢ä¸­ã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè‰²
            clearBoundingBoxes();
        }

        /**
         * Webã‚«ãƒ¡ãƒ©ã®ãƒˆãƒ©ãƒƒã‚¯ã‚’åœæ­¢ã™ã‚‹
         */
        function stopCameraTracks() {
            if (cameraStream) {
                const tracks = cameraStream.getTracks();
                tracks.forEach(track => track.stop()); 
                cameraStream = null;
            }
            video.srcObject = null;
        }

        /**
         * Webã‚«ãƒ¡ãƒ©ã‚’èµ·å‹•ã—ã€ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’é–‹å§‹ã™ã‚‹ï¼ˆå†ç”Ÿãƒªãƒˆãƒ©ã‚¤æ©Ÿèƒ½ä»˜ãï¼‰
         */
        async function startCamera(retryCount = 0) {
            if (retryCount === 0) {
                statusMessage.textContent = 'ã‚«ãƒ¡ãƒ©ã«ã‚¢ã‚¯ã‚»ã‚¹ä¸­...';
                statusMessage.style.color = '#3f51b5';
                try {
                    // 1. ã‚«ãƒ¡ãƒ©ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ã‚’è©¦ã¿ã‚‹ (ãƒ•ãƒ­ãƒ³ãƒˆã‚«ãƒ¡ãƒ©ã‚’å„ªå…ˆ)
                    const stream = await navigator.mediaDevices.getUserMedia({ 
                        video: { facingMode: "user" } 
                    });
                    
                    cameraStream = stream; 
                    video.srcObject = stream;

                    // 2. ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ãŒãƒ­ãƒ¼ãƒ‰ã•ã‚Œã‚‹ã®ã‚’å¾…ã¤
                    await new Promise(resolve => {
                        video.onloadedmetadata = () => resolve();
                        setTimeout(resolve, 2000); 
                    });

                    if (video.videoWidth > 0 && video.videoHeight > 0) {
                        canvas.width = video.videoWidth;
                        canvas.height = video.videoHeight;
                    }

                } catch (err) {
                    console.error("ã‚«ãƒ¡ãƒ©ã‚¢ã‚¯ã‚»ã‚¹ã‚¨ãƒ©ãƒ¼: ", err);
                    const name = err.name || 'UnknownError';
                    statusMessage.textContent = `è‡´å‘½çš„ãªã‚¨ãƒ©ãƒ¼: ${name}ã€‚ãƒ–ãƒ©ã‚¦ã‚¶è¨­å®šã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚`;
                    statusMessage.style.color = '#F44336';
                    startStopButton.textContent = 'ã‚«ãƒ¡ãƒ©é–‹å§‹';
                    return; 
                }
            }
            
            // 3. ãƒ“ãƒ‡ã‚ªã®å†ç”Ÿã‚’è©¦ã¿ã‚‹ (ãƒ¦ãƒ¼ã‚¶ãƒ¼æ“ä½œãŒãƒˆãƒªã‚¬ãƒ¼)
            video.play().then(() => {
                // å†ç”ŸæˆåŠŸæ™‚ã®å‡¦ç†
                startStopButton.textContent = 'ã‚«ãƒ¡ãƒ©åœæ­¢';
                statusMessage.textContent = 'ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹: ç¨¼åƒä¸­...';
                statusMessage.style.color = '#4CAF50'; 
                
                isProcessing = true;
                intervalId = setInterval(sendFrameToServer, CAPTURE_INTERVAL);
            }).catch(async err => {
                // å†ç”Ÿå¤±æ•—æ™‚ã®å‡¦ç† (é€šå¸¸ã€è‡ªå‹•å†ç”Ÿãƒ–ãƒ­ãƒƒã‚¯)
                console.error(`ãƒ“ãƒ‡ã‚ªå†ç”Ÿã‚¨ãƒ©ãƒ¼ (è©¦è¡Œ ${retryCount + 1}): `, err);
                
                if (retryCount < MAX_RETRIES) {
                    statusMessage.textContent = `å†ç”Ÿã«å¤±æ•—ã—ã¾ã—ãŸã€‚å†è©¦è¡Œä¸­... (${retryCount + 1}/${MAX_RETRIES})`;
                    await new Promise(resolve => setTimeout(resolve, 500)); 
                    await startCamera(retryCount + 1); 
                } else {
                    statusMessage.textContent = 'ã‚¨ãƒ©ãƒ¼: å†ç”ŸãŒãƒ–ãƒ­ãƒƒã‚¯ã•ã‚Œã¾ã—ãŸã€‚ãƒœã‚¿ãƒ³ã‚’ã‚‚ã†ä¸€åº¦æŠ¼ã—ã¦ãã ã•ã„ã€‚';
                    // å¤±æ•—ã—ãŸå ´åˆã¯ã€ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’è§£æ”¾
                    stopCameraTracks();
                    startStopButton.textContent = 'ã‚«ãƒ¡ãƒ©é–‹å§‹';
                }
            });
        }

        /**
         * æ¤œå‡ºçµæœã®æ ç·šã‚’å…¨ã¦ã‚¯ãƒªã‚¢ã™ã‚‹
         */
        function clearBoundingBoxes() {
            const oldBoxes = container.querySelectorAll('.bounding-box');
            oldBoxes.forEach(box => box.remove());
        }

        /**
         * ã‚µãƒ¼ãƒãƒ¼ã«ç¾åœ¨ã®ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’é€ä¿¡ã—ã€æ¤œå‡ºçµæœã‚’å—ã‘å–ã‚‹
         */
        async function sendFrameToServer() {
            if (!video.srcObject || video.paused || video.ended || !isProcessing) return;
            
            // 1. ç¾åœ¨ã®ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’Canvasã«æç”»
            context.drawImage(video, 0, 0, canvas.width, canvas.height);

            // 2. Canvasã®å†…å®¹ã‚’ãƒã‚¤ãƒŠãƒªãƒ‡ãƒ¼ã‚¿ï¼ˆBlobï¼‰ã¨ã—ã¦å–å¾—
            canvas.toBlob(async (blob) => {
                const formData = new FormData();
                formData.append('image', blob, 'frame.jpeg'); 

                clearBoundingBoxes();

                try {
                    // ğŸ’¥ ä¿®æ­£ç®‡æ‰€ ğŸ’¥ Renderã®å…¬é–‹URLã‚’ä½¿ç”¨ã—ã¾ã™ã€‚
                    // URLã¯ã€Œhttps://my-program-page.onrender.com/detect_objectã€
                    const API_URL = 'https://my-program-page.onrender.com/detect_object'; 

                    const response = await fetch(API_URL, {
                        method: 'POST',
                        body: formData,
                    });

                    const data = await response.json();

                    if (response.ok && data.success) {
                        statusMessage.textContent = `${data.detections.length}å€‹ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æ¤œå‡ºä¸­...`;
                        
                        data.detections.forEach(detection => {
                            // detection: {x, y, w, h} ã‚’æƒ³å®š
                            drawBoundingBox(detection.x, detection.y, detection.w, detection.h, video);
                        });
                    } else {
                        throw new Error(data.error || `HTTPã‚¨ãƒ©ãƒ¼ ${response.status}`);
                    }
                } catch (error) {
                    console.error("é€šä¿¡ã‚¨ãƒ©ãƒ¼ã¾ãŸã¯ã‚µãƒ¼ãƒãƒ¼å‡¦ç†ã‚¨ãƒ©ãƒ¼:", error);
                    statusMessage.textContent = 'ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿã€‚æ¤œå‡ºã‚’åœæ­¢ã—ã¾ã—ãŸã€‚';
                    statusMessage.style.color = '#F44336'; 
                    stopDetection(); // è‡ªå‹•çš„ã«åœæ­¢
                }
            }, 'image/jpeg', 0.8);
        }

        /**
         * æ¤œå‡ºçµæœã®çŸ©å½¢ã‚’HTMLã§æç”»ã™ã‚‹é–¢æ•°
         */
        function drawBoundingBox(x, y, w, h, videoElement) {
            const scaleX = videoElement.clientWidth / videoElement.videoWidth;
            const scaleY = videoElement.clientHeight / videoElement.videoHeight;
            
            const box = document.createElement('div');
            box.className = 'bounding-box';
            
            // åè»¢è£œæ­£ (CSSã® transform: scaleX(-1) ã«å¯¾å¿œ)
            box.style.left = `${(videoElement.clientWidth - (x + w) * scaleX)}px`;
            box.style.top = `${y * scaleY}px`;
            box.style.width = `${w * scaleX}px`;
            box.style.height = `${h * scaleY}px`;
            
            container.appendChild(box);
        }

        // ãƒšãƒ¼ã‚¸ãƒ­ãƒ¼ãƒ‰æ™‚ã«è‡ªå‹•å®Ÿè¡Œã›ãšã€ãƒœã‚¿ãƒ³ã‚¯ãƒªãƒƒã‚¯ã‚’å¾…ã¤
        startStopButton.addEventListener('click', startStopDetection);

        // ãƒšãƒ¼ã‚¸ãŒé–‰ã˜ã‚‰ã‚ŒãŸã¨ãã«ã‚«ãƒ¡ãƒ©ã‚’åœæ­¢
        window.addEventListener('beforeunload', stopDetection);
    </script>
</body>
</html>